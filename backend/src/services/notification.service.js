const { PrismaClient } = require('../generated/prisma');

class NotificationService {
  constructor() {
    this.prisma = new PrismaClient();
  }

  /**
   * Limpar markdown de uma string, mantendo emojis
   */
  cleanMarkdown(text) {
    if (!text) return text;
    
    // Remover markdown b√°sico, mas manter emojis
    return text
      .replace(/\*\*(.*?)\*\*/g, '$1') // **bold** -> bold
      .replace(/\*(.*?)\*/g, '$1')     // *italic* -> italic
      .replace(/`(.*?)`/g, '$1')       // `code` -> code
      .replace(/\[(.*?)\]\(.*?\)/g, '$1') // [text](url) -> text
      .replace(/^#{1,6}\s+/gm, '')    // # heading -> heading
      .replace(/^\s*[-*+]\s+/gm, '')  // - list item -> list item
      .replace(/^\s*\d+\.\s+/gm, '')  // 1. list item -> list item
      .replace(/\n\s*\n/g, '\n')      // M√∫ltiplas quebras de linha -> uma
      .trim();
  }

  /**
   * Obter emoji baseado no tipo de notifica√ß√£o
   */
  getNotificationEmoji(type) {
    const emojiMap = {
      'balance_change': 'üí∞',
      'token_received': 'üì•',
      'token_sent': 'üì§',
      'system': 'üîî',
      'warning': '‚ö†Ô∏è',
      'success': '‚úÖ',
      'error': '‚ùå',
      'info': '‚ÑπÔ∏è'
    };
    
    return emojiMap[type] || 'üîî';
  }

  /**
   * Criar uma nova notifica√ß√£o
   */
  async createNotification(data) {
    try {
      const notification = await this.prisma.notification.create({
        data: {
          userId: data.userId,
          sender: data.sender || 'coinage',
          title: data.title,
          message: data.message,
          isRead: false,
          isActive: true
        }
      });
      
      // Emitir evento para notifica√ß√µes em tempo real
      this.emitNotificationEvent(notification);
      
      return notification;
    } catch (error) {
      console.error('Erro ao criar notifica√ß√£o:', error);
      throw error;
    }
  }

  /**
   * Emitir evento de notifica√ß√£o criada
   */
  emitNotificationEvent(notification) {
    try {
      // Emitir evento no processo para que outros componentes possam escutar
      process.emit('notification:created', {
        userId: notification.userId,
        notification: notification,
        timestamp: new Date().toISOString()
      });
      
      // Se existir WebSocket global, emitir para o usu√°rio espec√≠fico
      if (global.io) {
        global.io.to(`user:${notification.userId}`).emit('notification', {
          notification: notification,
          timestamp: new Date().toISOString()
        });
      }
      
    } catch (error) {
      console.error('‚ùå Erro ao emitir evento de notifica√ß√£o:', error);
    }
  }

  /**
   * Listar todas as notifica√ß√µes de um usu√°rio (incluindo exclu√≠das)
   */
  async getAllNotifications(userId) {
    try {
      const notifications = await this.prisma.notification.findMany({
        where: {
          userId: userId
        },
        orderBy: {
          createdAt: 'desc'
        }
      });
      return notifications;
    } catch (error) {
      console.error('Erro ao buscar todas as notifica√ß√µes:', error);
      throw error;
    }
  }

  /**
   * Listar todas as notifica√ß√µes ativas de um usu√°rio
   */
  async getActiveNotifications(userId) {
    try {
      const notifications = await this.prisma.notification.findMany({
        where: {
          userId: userId,
          isActive: true
        },
        orderBy: {
          createdAt: 'desc'
        }
      });
      return notifications;
    } catch (error) {
      console.error('Erro ao buscar notifica√ß√µes:', error);
      throw error;
    }
  }

  /**
   * Obter notifica√ß√£o espec√≠fica por ID
   */
  async getNotificationById(notificationId, userId) {
    try {
      const notification = await this.prisma.notification.findFirst({
        where: {
          id: notificationId,
          userId: userId,
          isActive: true
        }
      });
      return notification;
    } catch (error) {
      console.error('Erro ao buscar notifica√ß√£o por ID:', error);
      throw error;
    }
  }

  /**
   * Listar notifica√ß√µes n√£o lidas de um usu√°rio
   */
  async getUnreadNotifications(userId) {
    try {
      const notifications = await this.prisma.notification.findMany({
        where: {
          userId: userId,
          isActive: true,
          isRead: false
        },
        orderBy: {
          createdAt: 'desc'
        }
      });
      return notifications;
    } catch (error) {
      console.error('Erro ao buscar notifica√ß√µes n√£o lidas:', error);
      throw error;
    }
  }

  /**
   * Marcar notifica√ß√£o como lida
   */
  async markAsRead(notificationId) {
    try {
      const notification = await this.prisma.notification.update({
        where: {
          id: notificationId
        },
        data: {
          isRead: true,
          readDate: new Date()
        }
      });
      return notification;
    } catch (error) {
      console.error('Erro ao marcar notifica√ß√£o como lida:', error);
      throw error;
    }
  }

  /**
   * Marcar notifica√ß√£o como n√£o lida
   */
  async markAsUnread(notificationId) {
    try {
      const notification = await this.prisma.notification.update({
        where: {
          id: notificationId
        },
        data: {
          isRead: false,
          readDate: null
        }
      });
      return notification;
    } catch (error) {
      console.error('Erro ao marcar notifica√ß√£o como n√£o lida:', error);
      throw error;
    }
  }

  /**
   * Marcar/desmarcar notifica√ß√£o como favorita
   */
  async toggleFavorite(notificationId) {
    try {
      const currentNotification = await this.prisma.notification.findUnique({
        where: { id: notificationId }
      });

      const notification = await this.prisma.notification.update({
        where: {
          id: notificationId
        },
        data: {
          isFavorite: !currentNotification.isFavorite
        }
      });
      return notification;
    } catch (error) {
      console.error('Erro ao alternar favorito da notifica√ß√£o:', error);
      throw error;
    }
  }

  /**
   * Marcar m√∫ltiplas notifica√ß√µes como lidas
   */
  async markMultipleAsRead(notificationIds) {
    try {
      const result = await this.prisma.notification.updateMany({
        where: {
          id: { in: notificationIds }
        },
        data: {
          isRead: true,
          readDate: new Date()
        }
      });
      return result;
    } catch (error) {
      console.error('Erro ao marcar m√∫ltiplas notifica√ß√µes como lidas:', error);
      throw error;
    }
  }

  /**
   * Marcar todas as notifica√ß√µes de um usu√°rio como lidas
   */
  async markAllAsRead(userId) {
    try {
      const result = await this.prisma.notification.updateMany({
        where: {
          userId: userId,
          isActive: true,
          isRead: false
        },
        data: {
          isRead: true,
          readDate: new Date()
        }
      });
      return result;
    } catch (error) {
      console.error('Erro ao marcar todas as notifica√ß√µes como lidas:', error);
      throw error;
    }
  }

  /**
   * Marcar todas as notifica√ß√µes de um usu√°rio como n√£o lidas
   */
  async markAllAsUnread(userId) {
    try {
      const result = await this.prisma.notification.updateMany({
        where: {
          userId: userId,
          isActive: true,
          isRead: true
        },
        data: {
          isRead: false,
          readDate: null
        }
      });
      return result;
    } catch (error) {
      console.error('Erro ao marcar todas as notifica√ß√µes como n√£o lidas:', error);
      throw error;
    }
  }

  /**
   * Excluir m√∫ltiplas notifica√ß√µes
   */
  async deleteMultipleNotifications(notificationIds) {
    try {
      const result = await this.prisma.notification.updateMany({
        where: {
          id: { in: notificationIds }
        },
        data: {
          isActive: false,
          deleteDate: new Date()
        }
      });
      return result;
    } catch (error) {
      console.error('Erro ao excluir m√∫ltiplas notifica√ß√µes:', error);
      throw error;
    }
  }

  /**
   * Restaurar notifica√ß√£o exclu√≠da
   */
  async restoreNotification(notificationId, userId) {
    try {
      const notification = await this.prisma.notification.update({
        where: {
          id: notificationId,
          userId: userId
        },
        data: {
          isActive: true,
          deleteDate: null
        }
      });
      return notification;
    } catch (error) {
      console.error('Erro ao restaurar notifica√ß√£o:', error);
      throw error;
    }
  }

  /**
   * Marcar notifica√ß√£o como exclu√≠da (soft delete)
   */
  async deleteNotification(notificationId) {
    try {
      const notification = await this.prisma.notification.update({
        where: {
          id: notificationId
        },
        data: {
          isActive: false,
          deleteDate: new Date()
        }
      });
      return notification;
    } catch (error) {
      console.error('Erro ao excluir notifica√ß√£o:', error);
      throw error;
    }
  }

  /**
   * Contar notifica√ß√µes n√£o lidas de um usu√°rio
   */
  async getUnreadCount(userId) {
    try {
      const count = await this.prisma.notification.count({
        where: {
          userId: userId,
          isActive: true,
          isRead: false
        }
      });
      return count;
    } catch (error) {
      console.error('Erro ao contar notifica√ß√µes n√£o lidas:', error);
      throw error;
    }
  }

  /**
   * Criar notifica√ß√£o de mudan√ßa de saldo de token
   */
  async createBalanceChangeNotification(userId, tokenSymbol, oldAmount, newAmount, changePercent, changeType) {
    try {
      const emoji = changeType === 'aumentou' ? 'üìà' : 'üìâ';
      const notification = await this.createNotification({
        userId: userId,
        sender: 'coinage',
        title: `${emoji} Mudan√ßa no saldo de ${tokenSymbol}`,
        message: `Seu saldo do token **${tokenSymbol}** ${changeType} de **${oldAmount}** para **${newAmount}** (${changePercent}%).`
      });
      
      return notification;
    } catch (error) {
      console.error('Erro ao criar notifica√ß√£o de mudan√ßa de saldo:', error);
      throw error;
    }
  }

  /**
   * Criar notifica√ß√£o de mudan√ßa de saldo de token
   */
  async createTokenBalanceChangeNotification(userId, oldBalance, newBalance, tokenSymbol, walletAddress) {
    try {
      const balanceChange = newBalance - oldBalance;
      const changeType = balanceChange > 0 ? 'recebeu' : 'perdeu';
      const changeAmount = Math.abs(balanceChange);
      
      let title, message;
      
      if (balanceChange > 0) {
        title = `üí∞ Recebimento de ${tokenSymbol}`;
        message = `Sua carteira **${walletAddress.slice(0, 6)}...${walletAddress.slice(-4)}** recebeu **${changeAmount.toFixed(6)} ${tokenSymbol}**. Saldo anterior: **${oldBalance.toFixed(6)}**, Saldo atual: **${newBalance.toFixed(6)}**.`;
      } else if (balanceChange < 0) {
        title = `üí∏ Transfer√™ncia de ${tokenSymbol}`;
        message = `Sua carteira **${walletAddress.slice(0, 6)}...${walletAddress.slice(-4)}** transferiu **${changeAmount.toFixed(6)} ${tokenSymbol}**. Saldo atual: **${newBalance.toFixed(6)}**.`;
      } else {
        return null; // Sem mudan√ßa
      }
      
      const notification = await this.createNotification({
        userId: userId,
        sender: 'coinage',
        title,
        message
      });
      
      return notification;
    } catch (error) {
      console.error('Erro ao criar notifica√ß√£o de mudan√ßa de saldo:', error);
      throw error;
    }
  }
}

module.exports = NotificationService;
