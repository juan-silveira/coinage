const prismaConfig = require('../config/prisma');
const redisService = require('./redis.service');
const blockchainService = require('./blockchain.service');
const TokenAmountService = require('./tokenAmount.service');

class UserCacheService {
  constructor() {
    this.activeSessions = new Map(); // userId -> session info
    this.refreshIntervals = new Map(); // userId -> interval ID
    this.CACHE_TTL = 300; // 5 minutos em segundos
    this.REFRESH_INTERVAL = 5 * 60 * 1000; // 5 minutos em ms
    this.prisma = null;
    this.tokenAmountService = new TokenAmountService();
  }

  /**
   * Inicializa o servi√ßo
   */
  async initialize() {
    try {
      this.prisma = prismaConfig.getPrisma();
      console.log('‚úÖ UserCacheService inicializado');
    } catch (error) {
      console.error('‚ùå Erro ao inicializar UserCacheService:', error);
      throw error;
    }
  }

  /**
   * Inicia sess√£o de cache para usu√°rio (acionado no login)
   */
  async startUserSession(userId, userEmail) {
    try {
      console.log(`üöÄ Iniciando sess√£o de cache para usu√°rio: ${userEmail} (${userId})`);
      
      // Parar sess√£o anterior se existir
      this.stopUserSession(userId);

      // Marcar sess√£o como ativa
      this.activeSessions.set(userId, {
        email: userEmail,
        startedAt: new Date(),
        lastRefresh: new Date()
      });

      // Carregar dados iniciais
      await this.loadUserCacheData(userId);

      // Configurar refresh autom√°tico a cada 5 minutos
      const intervalId = setInterval(async () => {
        if (this.activeSessions.has(userId)) {
          console.log(`üîÑ Atualizando cache autom√°tico para usu√°rio: ${userEmail}`);
          await this.loadUserCacheData(userId);
          
          // Atualizar √∫ltimo refresh
          if (this.activeSessions.has(userId)) {
            this.activeSessions.get(userId).lastRefresh = new Date();
          }
        } else {
          clearInterval(intervalId);
        }
      }, this.REFRESH_INTERVAL);

      this.refreshIntervals.set(userId, intervalId);
      
      console.log(`‚úÖ Sess√£o de cache iniciada para usu√°rio: ${userEmail}`);
      return true;
    } catch (error) {
      console.error(`‚ùå Erro ao iniciar sess√£o de cache para usu√°rio ${userId}:`, error);
      return false;
    }
  }

  /**
   * Para sess√£o de cache para usu√°rio (acionado no logout ou expira√ß√£o)
   */
  stopUserSession(userId) {
    try {
      if (this.refreshIntervals.has(userId)) {
        clearInterval(this.refreshIntervals.get(userId));
        this.refreshIntervals.delete(userId);
      }

      if (this.activeSessions.has(userId)) {
        const session = this.activeSessions.get(userId);
        console.log(`üõë Parando sess√£o de cache para usu√°rio: ${session.email} (${userId})`);
        this.activeSessions.delete(userId);
      }

      // Limpar cache do Redis para este usu√°rio
      this.clearUserCache(userId);
      
      return true;
    } catch (error) {
      console.error(`‚ùå Erro ao parar sess√£o de cache para usu√°rio ${userId}:`, error);
      return false;
    }
  }

  /**
   * Carrega dados do PostgreSQL e Blockchain para o cache Redis
   */
  async loadUserCacheData(userId) {
    try {
      console.log(`üì¶ [UserCacheService] loadUserCacheData iniciado para usu√°rio: ${userId}`);
      
      if (!this.prisma) await this.initialize();

      // 1. Carregar dados do PostgreSQL
      console.log(`üìä [UserCacheService] Carregando dados PostgreSQL...`);
      const postgresData = await this.loadPostgresData(userId);
      console.log(`‚úÖ [UserCacheService] Dados PostgreSQL carregados. PublicKey: ${postgresData.user.publicKey}`);
      
      // 2. Carregar dados da Blockchain
      console.log(`üîó [UserCacheService] Iniciando carregamento blockchain...`);
      const blockchainData = await this.loadBlockchainData(postgresData.user.publicKey);
      console.log(`‚úÖ [UserCacheService] Dados blockchain carregados:`, blockchainData);
      
      // 3. Detectar mudan√ßas nos saldos e criar notifica√ß√µes
      if (blockchainData.balancesTable) {
        await this.tokenAmountService.detectBalanceChanges(userId, blockchainData, postgresData.user.publicKey);
      }
      
      // 4. Combinar dados
      const combinedData = {
        postgres: postgresData,
        blockchain: blockchainData,
        lastUpdated: new Date().toISOString(),
        cacheVersion: '1.0'
      };

      // 5. Salvar no Redis
      await this.saveToCache(userId, combinedData);
      
      console.log(`‚úÖ Cache atualizado para usu√°rio: ${postgresData.email || userId}`);
      return combinedData;
    } catch (error) {
      console.error(`‚ùå Erro ao carregar dados do cache para usu√°rio ${userId}:`, error);
      throw error;
    }
  }

  /**
   * Carrega dados do PostgreSQL usando Prisma
   */
  async loadPostgresData(userId) {
    try {
      // Buscar dados do usu√°rio
      const user = await this.prisma.user.findUnique({
        where: { id: userId },
        include: {
          apiKeys: {
            where: { isActive: true },
            select: {
              id: true,
              name: true,
              description: true,
              isActive: true,
              expiresAt: true,
              lastUsedAt: true,
              createdAt: true
            }
          },
          userClients: {
            where: { status: 'active' },
            include: {
              client: {
                select: {
                  id: true,
                  name: true,
                  isActive: true
                }
              }
            }
          },
          userTwoFactors: {
            where: { isActive: true },
            select: {
              id: true,
              type: true,
              isActive: true,
              isVerified: true,
              lastUsedAt: true
            }
          }
        }
      });

      if (!user) {
        throw new Error('Usu√°rio n√£o encontrado');
      }

      // Buscar transa√ß√µes recentes
      const recentTransactions = await this.prisma.transaction.findMany({
        where: { 
          userId: userId,
          createdAt: {
            gte: new Date(Date.now() - 30 * 24 * 60 * 60 * 1000) // √öltimos 30 dias
          }
        },
        orderBy: { createdAt: 'desc' },
        take: 50,
        include: {
          contract: {
            select: {
              name: true,
              address: true
            }
          }
        }
      });

      // Buscar logs de requisi√ß√µes recentes
      const recentRequestLogs = await this.prisma.requestLog.findMany({
        where: { 
          userId: userId,
          createdAt: {
            gte: new Date(Date.now() - 7 * 24 * 60 * 60 * 1000) // √öltimos 7 dias
          }
        },
        orderBy: { createdAt: 'desc' },
        take: 100
      });

      // Estat√≠sticas do usu√°rio
      const userStats = {
        totalTransactions: await this.prisma.transaction.count({
          where: { userId }
        }),
        totalApiKeys: await this.prisma.apiKey.count({
          where: { userId, isActive: true }
        }),
        totalClients: user.userClients.length,
        twoFactorEnabled: user.userTwoFactors.length > 0
      };

      // Remover dados sens√≠veis
      const { password, privateKey, ...sanitizedUser } = user;

      return {
        user: sanitizedUser,
        transactions: recentTransactions,
        requestLogs: recentRequestLogs,
        stats: userStats,
        loadedAt: new Date().toISOString()
      };
    } catch (error) {
      console.error(`‚ùå Erro ao carregar dados PostgreSQL para usu√°rio ${userId}:`, error);
      throw error;
    }
  }

  /**
   * Carrega dados da Blockchain
   */
  async loadBlockchainData(publicKey) {
    try {
      console.log(`üîç [UserCacheService] loadBlockchainData chamado com publicKey: ${publicKey}`);
      
      if (!publicKey) {
        console.log('‚ö†Ô∏è [UserCacheService] publicKey √© null/undefined, retornando dados vazios');
        return {
          balances: {},
          tokenBalances: [],
          network: 'testnet',
          totalTokens: 0,
          loadedAt: new Date().toISOString()
        };
      }

      console.log(`üöÄ [UserCacheService] Chamando blockchainService.getUserBalances(${publicKey})`);
      // Usar o servi√ßo blockchain existente
      const balanceData = await blockchainService.getUserBalances(publicKey);
      console.log(`‚úÖ [UserCacheService] Dados recebidos do blockchainService:`, balanceData);
      
      // Calcular categorias para o dashboard
      const categories = this.calculateCategories(balanceData);
      
      return {
        ...balanceData,
        categories,
        loadedAt: new Date().toISOString()
      };
    } catch (error) {
      console.error(`‚ùå Erro ao carregar dados blockchain para ${publicKey}:`, error);
      return {
        balances: {},
        tokenBalances: [],
        network: 'testnet',
        totalTokens: 0,
        error: error.message,
        loadedAt: new Date().toISOString()
      };
    }
  }

  /**
   * Calcula valores por categoria para o dashboard
   */
  calculateCategories(balanceData) {
    try {
      // Mapeamento de tokens por categoria (igual ao frontend)
      const tokenCategories = {
        cryptocurrencies: ['AZE', 'AZE-t'], // cBRL n√£o vai aqui conforme solicitado
        startups: ['CNT'],
        utility: ['MJD'],
        digital: ['PCN']
      };

      // Pre√ßos dos tokens em BRL (mock - ser√° substitu√≠do por dados reais)
      const tokenPrices = {
        'AZE': 1.00,
        'AZE-t': 1.00,
        'cBRL': 1.00,
        'CNT': 1.00,
        'MJD': 1.00,
        'PCN': 1.00
      };

      const categories = {};
      let totalPortfolio = 0;
      let availableBalance = 0; // cBRL

      // Calcular cBRL dispon√≠vel (n√£o vai em nenhuma categoria do gr√°fico)
      if (balanceData.balancesTable && balanceData.balancesTable['cBRL']) {
        availableBalance = parseFloat(balanceData.balancesTable['cBRL']) || 0;
        totalPortfolio += availableBalance;
      }

      // Processar cada categoria
      Object.entries(tokenCategories).forEach(([categoryKey, tokens]) => {
        let categoryTotal = 0;

        tokens.forEach(symbol => {
          let balance = 0;
          
          // Buscar balance na tabela de balances
          if (balanceData.balancesTable && balanceData.balancesTable[symbol]) {
            balance = parseFloat(balanceData.balancesTable[symbol]) || 0;
          }
          
          // Calcular valor em BRL
          const price = tokenPrices[symbol] || 1.00;
          const valueBRL = balance * price;
          
          categoryTotal += valueBRL;
        });

        categories[categoryKey] = {
          name: this.getCategoryDisplayName(categoryKey),
          value: categoryTotal,
          tokens: tokens
        };

        totalPortfolio += categoryTotal;
      });

      return {
        categories,
        availableBalance, // cBRL
        totalPortfolio,
        totalInvested: totalPortfolio - availableBalance, // Soma das categorias
        projectedBalance: 0, // Para implementar com stake
        totalInOrder: 0 // Para implementar com livro de ofertas
      };
    } catch (error) {
      console.error('‚ùå Erro ao calcular categorias:', error);
      return {
        categories: {},
        availableBalance: 0,
        totalPortfolio: 0,
        totalInvested: 0,
        projectedBalance: 0,
        totalInOrder: 0
      };
    }
  }

  /**
   * Retorna nome de exibi√ß√£o da categoria
   */
  getCategoryDisplayName(categoryKey) {
    const displayNames = {
      cryptocurrencies: 'Criptomoedas',
      startups: 'Startups', 
      utility: 'Utility Tokens',
      digital: 'Renda Digital'
    };
    return displayNames[categoryKey] || categoryKey;
  }



  /**
   * Salva dados no cache Redis
   */
  async saveToCache(userId, data) {
    try {
      if (!redisService.isConnected || !redisService.client) {
        console.warn('‚ö†Ô∏è Redis n√£o conectado, ignorando cache');
        return false;
      }

      const cacheKey = `user_cache:${userId}`;
      await redisService.client.setEx(cacheKey, this.CACHE_TTL, JSON.stringify(data));
      
      // Salvar tamb√©m chaves espec√≠ficas para acesso r√°pido
      await redisService.client.setEx(`user_postgres:${userId}`, this.CACHE_TTL, JSON.stringify(data.postgres));
      await redisService.client.setEx(`user_blockchain:${userId}`, this.CACHE_TTL, JSON.stringify(data.blockchain));
      
      return true;
    } catch (error) {
      console.error(`‚ùå Erro ao salvar cache para usu√°rio ${userId}:`, error);
      return false;
    }
  }

  /**
   * Busca dados do cache Redis
   */
  async getCachedData(userId, dataType = 'all') {
    try {
      if (!redisService.isConnected || !redisService.client) {
        console.warn('‚ö†Ô∏è Redis n√£o conectado, cache indispon√≠vel');
        return null;
      }

      let cacheKey;
      switch (dataType) {
        case 'postgres':
          cacheKey = `user_postgres:${userId}`;
          break;
        case 'blockchain':
          cacheKey = `user_blockchain:${userId}`;
          break;
        default:
          cacheKey = `user_cache:${userId}`;
      }

      const cachedData = await redisService.client.get(cacheKey);
      if (cachedData) {
        return JSON.parse(cachedData);
      }
      
      return null;
    } catch (error) {
      console.error(`‚ùå Erro ao buscar cache para usu√°rio ${userId}:`, error);
      return null;
    }
  }

  /**
   * Limpa cache do usu√°rio
   */
  async clearUserCache(userId) {
    try {
      if (!redisService.isConnected || !redisService.client) {
        console.warn('‚ö†Ô∏è Redis n√£o conectado, ignorando limpeza de cache');
        return false;
      }

      const cacheKeys = [
        `user_cache:${userId}`,
        `user_postgres:${userId}`,
        `user_blockchain:${userId}`
      ];

      if (cacheKeys.length > 0) {
        await redisService.client.del(cacheKeys);
      }
      
      console.log(`üóëÔ∏è Cache limpo para usu√°rio: ${userId}`);
      return true;
    } catch (error) {
      console.error(`‚ùå Erro ao limpar cache para usu√°rio ${userId}:`, error);
      return false;
    }
  }

  /**
   * For√ßa atualiza√ß√£o do cache (ap√≥s a√ß√µes que modificam dados)
   */
  async refreshUserCache(userId) {
    try {
      if (this.activeSessions.has(userId)) {
        console.log(`üîÑ For√ßando atualiza√ß√£o de cache para usu√°rio: ${userId}`);
        await this.loadUserCacheData(userId);
        
        // Atualizar timestamp de √∫ltimo refresh
        this.activeSessions.get(userId).lastRefresh = new Date();
        return true;
      } else {
        console.log(`‚ö†Ô∏è Usu√°rio ${userId} n√£o tem sess√£o ativa, ignorando refresh`);
        return false;
      }
    } catch (error) {
      console.error(`‚ùå Erro ao for√ßar refresh do cache para usu√°rio ${userId}:`, error);
      return false;
    }
  }

  /**
   * Verifica se usu√°rio tem sess√£o ativa
   */
  isSessionActive(userId) {
    return this.activeSessions.has(userId);
  }

  /**
   * Lista sess√µes ativas (para debug/monitoramento)
   */
  getActiveSessions() {
    const sessions = [];
    for (const [userId, sessionData] of this.activeSessions) {
      sessions.push({
        userId,
        email: sessionData.email,
        startedAt: sessionData.startedAt,
        lastRefresh: sessionData.lastRefresh,
        duration: Date.now() - sessionData.startedAt.getTime()
      });
    }
    return sessions;
  }

  /**
   * Limpa todas as sess√µes (para reinicializa√ß√£o do servi√ßo)
   */
  clearAllSessions() {
    console.log('üßπ Limpando todas as sess√µes de cache...');
    
    // Parar todos os intervals
    for (const intervalId of this.refreshIntervals.values()) {
      clearInterval(intervalId);
    }
    
    // Limpar maps
    this.refreshIntervals.clear();
    this.activeSessions.clear();
    
    console.log('‚úÖ Todas as sess√µes de cache foram limpas');
  }

  /**
   * Testa o servi√ßo
   */
  async testService() {
    try {
      const testData = {
        test: true,
        timestamp: new Date().toISOString()
      };

      // Teste de escrita e leitura no Redis
      if (!redisService.isConnected || !redisService.client) {
        throw new Error('Redis n√£o est√° conectado');
      }
      
      await redisService.client.setEx('test_cache', 60, JSON.stringify(testData));
      const retrieved = await redisService.client.get('test_cache');
      await redisService.client.del('test_cache');

      const isWorking = retrieved && JSON.parse(retrieved).test === true;

      return {
        success: isWorking,
        message: isWorking ? 'UserCacheService funcionando corretamente' : 'Erro no teste do Redis',
        activeSessions: this.activeSessions.size,
        activeIntervals: this.refreshIntervals.size,
        timestamp: new Date().toISOString()
      };
    } catch (error) {
      return {
        success: false,
        message: 'Erro no UserCacheService',
        error: error.message,
        timestamp: new Date().toISOString()
      };
    }
  }
}

// Singleton instance
const userCacheService = new UserCacheService();

// Graceful shutdown - limpar sess√µes ao encerrar processo
process.on('SIGTERM', () => {
  console.log('üõë SIGTERM recebido, limpando sess√µes de cache...');
  userCacheService.clearAllSessions();
});

process.on('SIGINT', () => {
  console.log('üõë SIGINT recebido, limpando sess√µes de cache...');
  userCacheService.clearAllSessions();
});

module.exports = userCacheService;